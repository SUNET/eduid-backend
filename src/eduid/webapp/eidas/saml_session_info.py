# -*- coding: utf-8 -*-

import logging
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from dateutil.parser import parse as dt_parse
from pydantic import BaseModel, Field, root_validator

from eduid.userdb.identity import PridPersistence

__author__ = 'lundberg'


logger = logging.getLogger(__name__)


class BaseSessionInfo(BaseModel):
    issuer: str
    authn_info: List[Tuple[str, List[str], str]]

    @property
    def authn_context(self) -> Optional[str]:
        try:
            return self.authn_info[0][0]
        except KeyError:
            return None

    @property
    def authn_instant(self) -> datetime:
        return dt_parse(self.authn_info[0][2])


class SAMLAttributes(BaseModel):
    # pysaml returns attributes in lists, we never used anything other than index 0
    # so lets just do that for everything on load
    @root_validator(pre=True)
    def unwind_value(cls, values: Dict[str, List[str]]) -> Dict[str, str]:
        # log if we get any attributes values with more than one entry
        for key, value in values.items():
            if not isinstance(value, list):
                raise ValueError('attribute value is not a list')
            if len(value) > 1:
                logger.warning(f'got attributes with {key} that has more than one value')
                logger.debug(f'attributes: {values}')
        return dict([(key, value[0]) for key, value in values.items() if value])


class NinAttributes(SAMLAttributes):
    nin: str = Field(alias='personalIdentityNumber')
    given_name: str = Field(alias='givenName')
    surname: str = Field(alias='sn')
    display_name: Optional[str] = Field(default=None, alias='displayName')
    date_of_birth: str = Field(alias='dateOfBirth')


class ForeignEidAttributes(SAMLAttributes):
    # The prid attribute is designed to provide one common unique attribute of the user in a common format regardless
    # of the composition of the original attributes received from the authenticating source.
    prid: str
    prid_persistence: PridPersistence = Field(alias='pridPersistence')
    # The Unique Identifier (eidasPersonIdentifier) shall remain unchanged for the lifetime of the account
    # (as created by the underlying scheme or generated by the sending Node). A Unique Identifier shall never be
    # reused, e.g. a new Unique Identifier shall not match a Unique Identifier that has been deleted.
    # Any service that consumes assertions of identity must assume that the Unique Identifier
    # presented for a particular person may change over time e.g. where the userâ€™s digital identity is
    # replaced or repaired. This should be handled by a consuming service using the same
    # matching process as used when an identity is first encountered utilising the Minimum Data
    # Set to identify the Principal within the service.
    eidas_person_identifier: str = Field(alias='eidasPersonIdentifier')
    date_of_birth: str = Field(alias='dateOfBirth')
    given_name: str = Field(alias='givenName')
    surname: str = Field(alias='sn')
    country_code: str = Field(alias='c')
    transaction_identifier: str = Field(alias='transactionIdentifier')
    # there are plans for a service in the future that provides the attributes below for
    # swedish citizens living abroad with eID from the country of residence
    mapped_personal_identity_number: Optional[str] = Field(alias='mappedPersonalIdentityNumber')
    personal_identity_number_binding: Optional[str] = Field(alias='personalIdentityNumberBinding')


class NinSessionInfo(BaseSessionInfo):
    attributes: NinAttributes = Field(alias='ava')


class ForeignEidSessionInfo(BaseSessionInfo):
    attributes: ForeignEidAttributes = Field(alias='ava')
