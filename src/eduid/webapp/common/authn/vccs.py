import logging
from typing import cast

from bson import ObjectId

from eduid.common.decorators import deprecated
from eduid.userdb.credentials import Password
from eduid.userdb.element import ElementKey
from eduid.userdb.user import User
from eduid.vccs.client import VCCSClient, VCCSClientHTTPError, VCCSPasswordFactor, VCCSRevokeFactor

logger = logging.getLogger(__name__)


def get_vccs_client(vccs_url: str | None) -> VCCSClient:
    """
    Instantiate a VCCS client.

    :param vccs_url: VCCS authentication backend URL
    :return: vccs client
    """
    return VCCSClient(base_url=vccs_url)


def check_password(
    password: str, user: User, vccs_url: str | None = None, vccs: VCCSClient | None = None
) -> Password | None:
    """
    Try to validate a user provided password.

    :param password: plaintext password
    :param user: User object
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Password credential on success
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    for user_password in user.credentials.filter(Password):
        factor = VCCSPasswordFactor(password, credential_id=user_password.key, salt=user_password.salt)
        try:
            if vccs.authenticate(str(user.user_id), [factor]):
                return user_password
        except Exception:
            logger.exception(f"VCCS authentication for user {user} factor {factor} failed")
    return None


def add_password(
    user: User,
    new_password: str,
    application: str,
    is_generated: bool = False,
    vccs_url: str | None = None,
    vccs: VCCSClient | None = None,
) -> bool:
    """
    :param user: User object
    :param new_password: plaintext new password
    :param application: Application requesting credential change
    :param is_generated: True if this is a password generated by the eduID backend, rather than chosen by the user
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Success or not
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    # TODO: Init VCCSPasswordFactor with password hash instead of plain text password
    new_factor = VCCSPasswordFactor(new_password, credential_id=str(ObjectId()))

    # Add the new password
    if not vccs.add_credentials(str(user.user_id), [new_factor]):
        logger.error(f"Failed adding password credential {new_factor.credential_id} for user {user}")
        return False  # something failed
    logger.info(f"Added password credential {new_factor.credential_id} for user {user}")

    # Add new password to user
    _password = Password(
        credential_id=new_factor.credential_id, salt=new_factor.salt, is_generated=is_generated, created_by=application
    )
    user.credentials.add(_password)
    return True


def reset_password(
    user: User,
    new_password: str,
    application: str,
    is_generated: bool = False,
    vccs_url: str | None = None,
    vccs: VCCSClient | None = None,
) -> bool:
    """
    :param user: User object
    :param new_password: plaintext new password
    :param application: Application requesting credential change
    :param is_generated: True if this is a password generated by the eduID backend, rather than chosen by the user
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Success or not
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    # TODO: Init VCCSPasswordFactor with password hash instead of plain text password
    new_factor = VCCSPasswordFactor(new_password, credential_id=str(ObjectId()))

    # Revoke all existing passwords
    if not revoke_passwords(user, "password reset", application=application, vccs=vccs):
        # TODO: Not sure if ignoring errors is the right thing to do here. Old credential might be compromised.
        logger.error(f"Failed revoking password credentials for user {user} - proceeding anyways")

    # Add the new password
    if not vccs.add_credentials(str(user.user_id), [new_factor]):
        logger.error(f"Failed adding password credential {new_factor.credential_id} for user {user}")
        return False  # something failed
    logger.info(f"Added password credential {new_factor.credential_id} for user {user}")

    # Add new password to user
    _password = Password(
        credential_id=new_factor.credential_id, salt=new_factor.salt, is_generated=is_generated, created_by=application
    )
    user.credentials.add(_password)
    return True


def change_password(
    user: User,
    new_password: str,
    application: str,
    old_password: str | None = None,
    old_password_id: str | None = None,
    is_generated: bool = False,
    vccs_url: str | None = None,
    vccs: VCCSClient | None = None,
) -> bool:
    """
    :param user: User object
    :param new_password: Plaintext new password
    :param old_password: Plaintext current password
    :param old_password_id: Id for password that was used for reauthn
    :param application: Application requesting credential change
    :param is_generated: True if this is a password generated by the eduID backend, rather than chosen by the user
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Success or not
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    # TODO: Init VCCSPasswordFactor with password hash instead of plain text password
    new_factor = VCCSPasswordFactor(new_password, credential_id=str(ObjectId()))
    del new_password  # don't need it anymore, try to forget it

    # Check that the old password is correct, if supplied
    checked_password = None
    if old_password is not None:
        checked_password = check_password(old_password, user, vccs_url=vccs_url, vccs=vccs)
        del old_password  # don't need it anymore, try to forget it
        if not checked_password:
            logger.error("Old password did not match for user")
            return False

    # Revoke the old password or all current passwords as a fallback if old password or old password id is missing.
    if checked_password is not None or old_password_id is not None:
        revoke_password(
            user=user,
            reason="changing password",
            reference=application,
            old_password=checked_password,
            old_password_id=old_password_id,
            vccs_url=vccs_url,
            vccs=vccs,
        )
    else:
        # We don't know which password was used to reauthn, revoke all current passwords.
        revoke_passwords(user=user, reason="changing password", application=application, vccs_url=vccs_url, vccs=vccs)

    # Add the new password
    if not vccs.add_credentials(str(user.user_id), [new_factor]):
        logger.error(f"Failed adding password credential {new_factor.credential_id}")
        return False  # something failed
    logger.info(f"Added password credential {new_factor.credential_id}")

    # Add new password to user
    _password = Password(
        credential_id=new_factor.credential_id, salt=new_factor.salt, is_generated=is_generated, created_by=application
    )
    user.credentials.add(_password)
    return True


@deprecated
def add_credentials(
    old_password: str | None,
    new_password: str,
    user: User,
    source: str,
    vccs_url: str | None = None,
    vccs: VCCSClient | None = None,
) -> bool:
    """
    Add a new password to a user. Revokes the old one, if one is given.
    Revokes all old passwords if no old one is given - password reset.

    :param user: User object
    :param new_password: plaintext new password
    :param source: Application requesting credential change
    :param old_password: Plaintext current password
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Success status
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    new_factor = VCCSPasswordFactor(new_password, credential_id=str(ObjectId()))

    checked_password = None
    # remember if an old password was supplied or not, without keeping it in
    # memory longer than we have to
    old_password_supplied = bool(old_password)
    if len(user.credentials.filter(Password)) > 0 and old_password_supplied:
        assert old_password is not None  # mypy doesn't get that old_password can't be None here
        # Find the old credential to revoke
        checked_password = check_password(old_password, user, vccs_url=vccs_url, vccs=vccs)
        del old_password  # don't need it anymore, try to forget it
        if not checked_password:
            return False

    if not vccs.add_credentials(str(user.user_id), [new_factor]):
        logger.warning(f"Failed adding password credential {new_factor.credential_id!r} for user {user!r}")
        return False  # something failed
    logger.debug(f"Added password credential {new_factor.credential_id!s} for user {user!s}")

    if checked_password:
        old_factor = VCCSRevokeFactor(str(checked_password.credential_id), "changing password", reference=source)
        vccs.revoke_credentials(str(user.user_id), [old_factor])
        user.credentials.remove(checked_password.key)
        logger.debug(f"Revoked old credential {old_factor.credential_id!s} (user {user!s})")

    if not old_password_supplied:
        # XXX: Revoke all current credentials on password reset for now
        revoked = []
        for password in user.credentials.filter(Password):
            revoked.append(VCCSRevokeFactor(str(password.credential_id), "reset password", reference=source))
            logger.debug(f"Revoking old credential (password reset) {password.credential_id} (user {user})")
            user.credentials.remove(password.key)
        if revoked:
            try:
                vccs.revoke_credentials(str(user.user_id), revoked)
            except VCCSClientHTTPError:
                # Password already revoked
                # TODO: vccs backend should be changed to return something more informative than
                # TODO: VCCSClientHTTPError when the credential is already revoked or just return success.
                logger.warning(f"VCCS failed to revoke all passwords for user {user}")

    _new_cred = Password(credential_id=new_factor.credential_id, salt=new_factor.salt, created_by=source)
    user.credentials.add(_new_cred)
    return True


def revoke_password(
    user: User,
    reason: str,
    reference: str,
    old_password: Password | None = None,
    old_password_id: str | None = None,
    vccs_url: str | None = None,
    vccs: VCCSClient | None = None,
) -> bool:
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    credential_id = None
    credential_key = None
    if old_password is not None:
        credential_id = str(old_password.credential_id)
        credential_key = old_password.key
    elif old_password_id is not None:
        password = cast(Password, user.credentials.find(ElementKey(old_password_id)))
        if password:
            credential_id = str(password.credential_id)
            credential_key = password.key

    if credential_id is None or credential_key is None:
        return False

    # Revoke password
    vccs.revoke_credentials(
        str(user.user_id), [VCCSRevokeFactor(credential_id=credential_id, reason=reason, reference=reference)]
    )
    # Remove password from user
    user.credentials.remove(credential_key)
    logger.info(f"Revoked credential {credential_id}")
    return True


def revoke_passwords(
    user: User, reason: str, application: str, vccs_url: str | None = None, vccs: VCCSClient | None = None
) -> bool:
    """
    :param user: User object
    :param reason: Reason for revoking all passwords
    :param application: Application requesting credential change
    :param vccs_url: URL to VCCS authentication backend
    :param vccs: Optional already instantiated vccs client

    :return: Success or not
    """
    if vccs is None:
        vccs = get_vccs_client(vccs_url)

    revoke_factors = []
    for password in user.credentials.filter(Password):
        credential_id = str(password.key)
        factor = VCCSRevokeFactor(credential_id, reason, reference=application)
        logger.debug(f'Revoking credential {credential_id} for user {user} with reason "{reason}"')
        revoke_factors.append(factor)
        user.credentials.remove(password.key)

    userid = str(user.user_id)
    try:
        vccs.revoke_credentials(userid, revoke_factors)
    except VCCSClientHTTPError:
        # One of the passwords was already revoked
        # TODO: vccs backend should be changed to return something more informative than
        # TODO: VCCSClientHTTPError when the credential is already revoked or just return success.
        logger.warning(f"VCCS failed to revoke all passwords for user {user}")
        return False
    return True


@deprecated
def revoke_all_credentials(
    user: User, source: str = "dashboard", vccs_url: str | None = None, vccs: VCCSClient | None = None
) -> None:
    if vccs is None:
        vccs = get_vccs_client(vccs_url)
    to_revoke = []
    for password in user.credentials.filter(Password):
        credential_id = password.credential_id
        factor = VCCSRevokeFactor(credential_id, "subscriber requested termination", reference=source)
        logger.debug(f"Revoked old credential (account termination) {credential_id!s} (user {user!s})")
        to_revoke.append(factor)
    userid = str(user.user_id)
    vccs.revoke_credentials(userid, to_revoke)
